import pandas as pd
import numpy as np
import sys
import re
from io import StringIO
import contextlib

class DataTools:
    """
    A Generalizable Toolbox for the LLM. 
    Handles complex Pandas syntax and Sheet Selection logic.
    """
    def get_active_sheet(self, dfs):
        if not dfs or not isinstance(dfs, dict):
            return pd.DataFrame()
        for key in dfs.keys():
            key_str = str(key).lower()
            if "fy" in key_str or "year" in key_str or "summary" in key_str:
                return dfs[key]
        try:
            return list(dfs.values())[0]
        except IndexError:
            return pd.DataFrame()

    def get_value(self, df, row_label, col_label):
        try:
            if df.empty: return 0.0
            search_col = df.columns[0]
            mask = df[search_col].astype(str).str.contains(row_label, case=False, na=False)
            row = df[mask]
            if not row.empty:
                val = row[col_label].values[0]
                return pd.to_numeric(val, errors='coerce')
            return 0.0
        except Exception:
            return 0.0

    def get_column_sum(self, df, col_label):
        try:
            if col_label in df.columns:
                return pd.to_numeric(df[col_label], errors='coerce').sum()
            return 0.0
        except Exception:
            return 0.0

def execute_python_code(code: str, data: pd.DataFrame):
    """
    Executes Python code generated by the LLM in a controlled environment.
    Returns: tuple(output_string, modified_dataframe)
    """
    output_buffer = StringIO()
    
    code_match = re.search(r"```(?:\w+)?\n(.*?)```", code, re.DOTALL)
    clean_code = code_match.group(1).strip() if code_match else code.replace("```", "").strip()

    tools = DataTools()
    
    # Work on a COPY of the data so we don't corrupt the original if code fails
    working_df = data.copy() if isinstance(data, pd.DataFrame) else pd.DataFrame()

    execution_env = {
        "pd": pd,
        "np": np,
        "dfs": data,       # Legacy support
        "df": working_df,  # ðŸŸ¢ The Primary Object the AI will modify
        "tools": tools,
        "print": print,
        "len": len,
        "str": str,
        "int": int,
        "float": float,
        "list": list,
        "dict": dict,
        "range": range
    }
    
    try:
        with contextlib.redirect_stdout(output_buffer):
            exec(clean_code, execution_env, execution_env)
        
        result_text = output_buffer.getvalue()
        if not result_text:
            result_text = "Code executed successfully (No Output printed)."
        
        # ðŸŸ¢ Extract the potentially modified DataFrame
        cleaned_df = execution_env.get('df', working_df)

        return result_text.strip(), cleaned_df
        
    except Exception as e:
        return f"Error executing code: {str(e)}", data